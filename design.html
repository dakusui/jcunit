<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia Site Renderer 1.9.1 from src/site/asciidoc/design.adoc at 2022-06-06
 | Rendered using Apache Maven Fluido Skin 1.7
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="Date-Revision-yyyymmdd" content="20220606" />
    <meta http-equiv="Content-Language" content="en" />
    <title>jcunit &#x2013; </title>
    <link rel="stylesheet" href="./css/apache-maven-fluido-1.7.min.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />
    <script type="text/javascript" src="./js/apache-maven-fluido-1.7.min.js"></script>
  </head>
  <body class="topBarDisabled">
    <div class="container-fluid">
      <div id="banner">
        <div class="pull-left"><div id="bannerLeft"><h2>jcunit</h2>
</div>
</div>
        <div class="pull-right"></div>
        <div class="clear"><hr/></div>
      </div>

      <div id="breadcrumbs">
        <ul class="breadcrumb">
        <li id="publishDate">Last Published: 2022-06-06<span class="divider">|</span>
</li>
          <li id="projectVersion">Version: 0.10.0-SNAPSHOT</li>
        </ul>
      </div>
      <div class="row-fluid">
        <div id="leftColumn" class="span2">
          <div class="well sidebar-nav">
    <ul class="nav nav-list">
      <li class="nav-header">Documents</li>
    <li><a href="asciidoc/quickstart.html" title="Quick Start"><span class="none"></span>Quick Start</a></li>
    <li><a href="asciidoc/design.html" title="Design"><span class="none"></span>Design</a></li>
      <li class="nav-header">Project Documentation</li>
    <li><a href="project-info.html" title="Project Information"><span class="icon-chevron-right"></span>Project Information</a></li>
    <li><a href="project-reports.html" title="Project Reports"><span class="icon-chevron-right"></span>Project Reports</a></li>
</ul>
          <hr />
          <div id="poweredBy">
            <div class="clear"></div>
            <div class="clear"></div>
            <div class="clear"></div>
            <div class="clear"></div>
<a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy"><img class="builtBy" alt="Built by Maven" src="./images/logos/maven-feather.png" /></a>
            </div>
          </div>
        </div>
        <div id="bodyColumn"  class="span10" >
<h1>Design of JCUnit</h1>
<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#the_pipeline">The Pipeline</a></li>
<li><a href="#coordination_pipeline">Coordination Pipeline</a>
<ul class="sectlevel2">
<li><a href="#main_branch">Main Branch</a></li>
<li><a href="#NonSimpleParameterUnderConstraintBranch">Non-Simple-Parameter-Under-Constraint Branch</a></li>
<li><a href="#NegativeTestGenerationBranch">Negative Test Generation Branch</a></li>
</ul>
</li>
<li><a href="#EnginePipeline">The "Engine" Pipeline</a>
<ul class="sectlevel2">
<li><a href="#stages">Stages</a></li>
<li><a href="#encode">Encode</a></li>
<li><a href="#partition">Partition</a></li>
<li><a href="#generation">Generation</a></li>
<li><a href="#join">Join</a></li>
<li><a href="#decode">Decode</a></li>
</ul>
</li>
<li><a href="#references">References</a>
<ul class="sectlevel2">
<li><a href="#our_papers">Our papers</a></li>
<li><a href="#jcunit_tickets">JCUnit Tickets</a></li>
</ul>
</li>
</ul>
</div>
<div class="sect1">
<h2 id="the_pipeline">The Pipeline</h2>
<div class="sectionbody">
<div class="paragraph">
<p>JCUnit has a pipeline, which converts testing model containing user-defined parameters into an executable test suite.
Basic idea of it is following:
First, it converts the user-defined (human-understandable, high-level) parameters into factors and constraints, which can be processed by covering array generation engines.
Then, a covering array is generated from them.
Finally, the covering array is converted back to a test suite expressed in the human-understandable and high-level notation.</p>
</div>
<div class="paragraph">
<p>In order to provide popular features of CIT tools (such as seeding and negative testing) and practical performance under practical situations based on the idea, the pipeline has a carefully designed internal structure.
First, the pipeline has two levels, which are "Coordination" pipeline and "Engine" pipeline.
In each pipeline, there are a few branches and several stages.</p>
</div>
<div class="paragraph">
<p>In this section, we are going to walk through these levels, branches, and stages.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="coordination_pipeline">Coordination Pipeline</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The core idea of JCUnit is to convert human understandable model into factors and constraints.
Let CIT engine do the test suite generation.
Then, convert the test suite back to human understandable form.</p>
</div>
<div class="paragraph">
<div class="title">Coordination Pipeline</div>
<p><span class="image"><img src="./design/ThePipeline/Slide1.png" alt="Slide1"/></span></p>
</div>
<div class="sect2">
<h3 id="main_branch">Main Branch</h3>
<div class="paragraph">
<p>In the main branch, at first a non-simple parameters under constraint is dispatched to a special branch for the sake of performance.
This stage is called "Split".
The non-simple parameters sent to the special branches are then merged to construct a single parameter space ("Merge" stage).</p>
</div>
<div class="paragraph">
<p>Then the parameter space is sent to the next stage to generate a covering array for regular tests.
At the same time, the parameter space is also sent to a branch for the negative test generation (<a href="#NegativeTestGenerationBranch">Negative Test Generation Branch</a>).</p>
</div>
<div class="paragraph">
<p>The test cases generated by the both branches are stored into one collection ("Append" stage).</p>
</div>
<div class="paragraph">
<p>Finally, test case object, which executes methods in the test class based on annotations, is constructed ("Concretize" stage).</p>
</div>
</div>
<div class="sect2">
<h3 id="NonSimpleParameterUnderConstraintBranch">Non-Simple-Parameter-Under-Constraint Branch</h3>
<div class="paragraph">
<p>A "simple" parameter is directly converted into a factor and constraints that involve only simple parameters can be used in the generation stage without any conversion.</p>
</div>
<div class="paragraph">
<p>However, for non-simple-parameters, a different approach is required.
A constraint in JCUnit is implemented as a Java method which takes actual value of parameters the constraint are interested in.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class ExampleTest {
  public static boolean areValidInputValues(@From("a") int a, @From("b") int b) {
    // ...
    return checkedResult;
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The constraint method is called many times during the covering array generation and it will make the performance impractical.
When the parameter is not a simple one, but a custom one (e.g., Regex), the parameter and constraint definition will look like following.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import com.github.dakusui.jcunitx.runners.junit4.annotations.Condition;

public class ExampleTest {
  @ParameterSource
  public Regex.Factory sequence() {
    return Regex.Factory.of("open deposit(deposit|withdraw|transfer){0,2}getBalance");
  }

  @Condition(constraint = true)
  public static boolean isDesiredSequence(List&lt;String&gt; sequence) {
    // ...
    return checkedResult;
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The problem is, in order to call this method during the covering array generation, it involves encoding and decoding between the parameter value and internal representation happens every time.
This is in general too much expensive since a covering array generation engine needs to invoke it a huge number of times to find a row that minimizes the size of the output covering array.</p>
</div>
<div class="paragraph">
<p>What JCUnit does in this branch is to first process each non-simple parameter under a constraint by applying the "Engine" pipeline (<a href="#EnginePipeline">The "Engine" Pipeline</a>) to the parameter.
Then turn the generated covering array into a simple parameter whose levels are rows in the array.</p>
</div>
<div class="paragraph">
<p>With this approach, we can avoid evaluating the expensive step (encode/decode) every time the generation engine requires.
Instead, it only needs to invoke it with the decoded value in the latter part of the main branch.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
As described above, the current version of JCUnit converts all the non-simple parameters into simple ones.
This approach results in an increase in the size of the final test suite.
This behavior is designed based on the assumption where the encode/decode is always too expensive for the covering array generation process, however in case the meta-model is simply enough or in case it is encoded into a simple parameter with too many possible values, it might be preferable not to follow this step.
Making it possible to enable/disable the non-simple-parameter-under-constraint conversion step based on the encode/decode cost is one of the planned future enhancements.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="NegativeTestGenerationBranch">Negative Test Generation Branch</h3>
<div class="paragraph">
<p>A negative test means a test that verifies the behavior of the system under test (SUT) for the unwanted input.
In the CIT context, such input combinations are excluded by constraints.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class ExampleTest {
    @Given("!inputValuesAreValid")
    @Expected(ValidationFailed.class)
    public void whenPerformFunction$thenInvalidInputReported(@From("inputValue") String inputValue) {
        driver.performFunction();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>JCUnit has a special generator for negative tests.
For each constraint, it tries to generate a row (test case), which violates it and only it.
With this feature, you can write a test which verifies a behavior of SUT for unwanted input values by annotating a test method.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Currently, for every constraint regardless of whether it is synthesized as a result of the "Encode" stage or manually defined.
However, it is sometimes pointless to generate a negative test for such a synthesized constraint.
That is, a meta-model sometimes needs to generate internal constraints whose violation only causes a testing side issue.
This limitation is being addressed under <a href="#JCUnit-Issue-188">[JCUnit-Issue-188]</a>.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="EnginePipeline">The "Engine" Pipeline</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The "Engine" pipeline is responsible for generating a human-understandable test suite from a given human-understandable parameter model.</p>
</div>
<div class="paragraph">
<div class="title">Engine Pipeline</div>
<p><span class="image"><img src="./design/ThePipeline/Slide2.png" alt="Slide2"/></span></p>
</div>
<div class="paragraph">
<p>It is a broad concern in the model-based testing to address a problem called "state-space explosion".
To address this the approach, the JCUnit applies a technique called "Combinatorial Interaction Testing" to generate a small test with a good coverage over the testing domain.</p>
</div>
<div class="sect2">
<h3 id="stages">Stages</h3>
<div class="paragraph">
<p>This inner pipeline mainly consists of five stages, "Encode", "Partition", "Generation", "Join", and "Decode".</p>
</div>
<div class="paragraph">
<p>The high-level (human-understandable) parameter model is encoded into a model based on factors and constraints only in the first stage called "Encode".
The encoded factors and parameters are partitioned for the sake of scalability and flexibility.
For each partitioned group of factors and constraints, "Generation" stage, where CIT engine is executed to generate a mathematical object called a "covering array", is executed.</p>
</div>
<div class="paragraph">
<p>Then, covering arrays are connected by the "Join" stage.
As of today, the only practical way to construct a new covering array from existing ones without relying on covering array generation engine is a technique called "Combinatorial Join".
We use this technique in this stage.</p>
</div>
<div class="paragraph">
<p>Finally, the connected covering array is converted into the human-readable form by "Decode" stage.</p>
</div>
<div class="paragraph">
<p>In this section, we walk through the stages in the"Engine" pipeline, one by one.</p>
</div>
</div>
<div class="sect2">
<h3 id="encode">Encode</h3>
<div class="paragraph">
<p>This is a stage, where a parameter defined using a meta-model is converted into a set of factors and constraints.
The encoding procedure is provided as a part of each meta-model implementation.
Thanks to having this stage, JCUnit can handle various meta-models such as Input-parameter Model, Finite State Machines (FSM) Model, Regular Expression sequence, and so on.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Users of JCUnit can define arbitrary "meta-model" to define their testing model.
The meta-model is required to implement "encode" and "decode" operations.
"Encode" is responsible for encoding a model defined using the meta-model into factor-constraint model.
"Decode" is the other way around.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Depending on the design of the conversion specification, the number of factors and complexity of the constraints can be completely different.</p>
</div>
<div class="paragraph">
<p>JCUnit supports three meta-models out of box, which are finite state machines (FSM), regular expressions (Regex), and simple input parameters.
The design of the conversion by JCUnit can be found in the paper we published 2017<a href="#TestDesignAsCode">[TestDesignAsCode]</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="partition">Partition</h3>
<div class="paragraph">
<p>"Partition" stage splits a given set of factors and constraints into groups each of which no constraint references a factor outside the group.
This stage allows us two things.
One is to apply the "best" covering array generation engine for each group.
The other is to be able to mitigate the exponential growth of generation time along with the number of factors/the complexity of constraints.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
The default implementation for the "Partition" stage, extracts a group of factors which are not referenced by any constraints, first.
Then, it groups factors by constraints in the following manner.
It picks up one constraint and checks each factor if the factor is referenced by another constraint.
If it is, mark the factor and the check happens recursively for the referencing constraint.
Once this process is finished, the marked factors are extracted as a new group and the checked constraints are removed.
Until all the constraints are removed, the process is repeated.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The intention of this mechanism is to allow "divide-and-conquer" in the covering array generation process.
The encoding procedure may multiply the number of the factors and constraints.
Although the modern covering array generation engines are very scalable along with the number of factors, however, if once a constraint is introduced, the performance is drastically worsen, sometimes<a href="#PICT-Issue-13">[PICT-Issue-13]</a>.
JCUnit can mitigate this problem by this and "Join" mechanism.
Another benefit of having this step is to be able to choose the "best" covering array engine for each group.
For instance, when constraints are present, ACTS is faster than PICT.
However, if the constraints are not simple ones but relying on Java&#8217;s feature to check the value&#8217;s validity, JCUnit&#8217;s built-in covering array engine will be the only choice, even if it is slowest among those three.</p>
</div>
<div class="paragraph">
<p>You should also keep in ming that the "Join" stage causes a significant "size penalty", where covering array size is increased significantly for each combinatorial join operation.</p>
</div>
</div>
<div class="sect2">
<h3 id="generation">Generation</h3>
<div class="paragraph">
<p>"Generation" is the stage, where a covering array is generated from factors and constraints.
As long as the factors and constraints can be handled, the engine implementation is replaceable.<a href="#JCUnit-Issue-179">[JCUnit-Issue-179]</a></p>
</div>
</div>
<div class="sect2">
<h3 id="join">Join</h3>
<div class="paragraph">
<p>JCUnit employs an operation called "Combinatorial Join"<a href="#CombinatorialJoin">[CombinatorialJoin]</a><a href="#WP-CombinatorialJoin">[WP-CombinatorialJoin]</a> to construct a new covering arrays from existing ones not relying on a covering array generation array engine.
Since the combinatorial join operation can take onlyt two covering arrays as input, this stage is applied repeatedly.</p>
</div>
<div class="paragraph">
<p>However, it is very difficult to find a way to connect multiple covering arrays to construct a bigger covering array without creating a new row before "combinatorial join".
An instance for it is to treat an input covering array as a factor and each row in it as a level of the factor<a href="#Zamansky-2017">[Zamansky-2017]</a>.
In an industry scale setting, this results in an unacceptably huge covering array.</p>
</div>
<div class="paragraph">
<p>In order to address this problem, the developers of JCUnit, came up with operations called "combinatorial join"<a href="#CombinatorialJoin">[CombinatorialJoin]</a><a href="#WP-CombinatorialJoin">[WP-CombinatorialJoin]</a>.
It constructs a new covering array from existing two covering arrays.
With this operation, we can accelerate the covering array generation process even if there are a large number of factors and complex constraints.
Nevertheless, the operation introduces an increase in the output size, which we call "size penalty".
Also, the characteristics of the size penalty has not been studied well.
The optimal order to perform the combinatorial join operation for more than two covering arrays is subject to future studies.</p>
</div>
<div class="paragraph">
<p>By default, the JCUnit&#8217;s framework chooses the largest (the array that has the most rows) arrays repeatedly to construct a final covering array.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Thanks to the "partition" stage, it becomes able to "divide" a large testing space (i.e, the large number of factors and constraints) into smaller groups.
From each sub-problem is "conquered", if we can construct the desired artifact, one covering array that covers all the given factors under all the given constraints, the entire problem can be said solved.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="decode">Decode</h3>
<div class="paragraph">
<p>"Decode" stage is responsible for convert the test cases generated using the levels back into the high-level representation, i.e., a concrete value of the concrete value of a parameter given to "Encode" stage.
The decoding procedure is provided as a part of each meta-model implementation.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="references">References</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a id="PICT-Issue-13"></a> <a href="https://github.com/Microsoft/pict/issues/13">Endless calculation with following model</a></p>
</li>
<li>
<p><a id="Zamansky-2017"></a> <a href="https://ieeexplore.ieee.org/document/7899062">A Composition-Based Method for Combinatorial Test Design</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="our_papers">Our papers</h3>
<div class="ulist">
<ul>
<li>
<p><a id="TestDesignAsCode"></a> <a href="https://ieeexplore.ieee.org/document/7928008">Test Design as Code: JCUnit</a></p>
</li>
<li>
<p><a id="CombinatorialJoin"></a> <a href="https://ieeexplore.ieee.org/document/8728961">Reduce Test Cost by Reusing Test Oracles through Combinatorial Join</a></p>
</li>
<li>
<p><a id="WP-CombinatorialJoin"></a> <a href="https://peerj.com/articles/cs-720.pdf">Accelerating covering array generation by combinatorial join for industry scale software testing</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="jcunit_tickets">JCUnit Tickets</h3>
<div class="ulist">
<ul>
<li>
<p><a id="JCUnit-Issue-179"></a> <a href="https://github.com/dakusui/jcunit/issues/179">#179: Integrate PICT as a covering array generation engine</a></p>
</li>
<li>
<p><a id="JCUnit-Issue-188"></a> <a href="https://github.com/dakusui/jcunit/issues/188">#188: Make it possible to specify whether a negative test should be generated for each constraint</a></p>
</li>
<li>
<p><a id="JCUnit-Issue-189"></a> <a href="https://github.com/dakusui/jcunit/issues/189">#189: Make non-simple-parameter-under-constraint simplifying feature switchable based on cost</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
        </div>
      </div>
    </div>
    <hr/>
    <footer>
      <div class="container-fluid">
        <div class="row-fluid">
            <p>Copyright &copy;2022.
All rights reserved.</p>
        </div>
      </div>
    </footer>
  </body>
</html>
