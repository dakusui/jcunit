/**
 * This is a public API package of JCUnit.
 * If you want to generate a combinatorial test suite using JCUnit's functionality, but don't want to
 * run it under JUnit, you came to a right place. See also {@link com.github.dakusui.jcunit.framework.TestSuite.Builder}.
 * <p/>
 * Following is a diagram that illustrates relationships between entities that you need to know to
 * build a {@link com.github.dakusui.jcunit.framework.TestSuite} object without relying on JCUnit's test runner.
 * <pre>
 *   +-----------------+                                      +--------------------+
 *   | List< TestCase >|                                      |Map< String,Object >|
 *   +-----------------+                                      +--------------------+
 *            |                                                         |
 *            A                                                         A
 *            |                                                         |
 *   +-----------------+      +---------+       +-----------+        +-----+
 *   |TestSuite.Builder|- - ->|TestSuite|<>---->|TestCase   |<>----->|Tuple|
 *   +-----------------+      +---------+ 1   * +-----------+ 1    1 +-----+
 *           1|                                 |Type  type |
 *            |                                 +-----------+
 *            |
 *            |               +---------------------------+
 *            +-------------->|TestSuite.Builder.Predicate|
 *                          * +---------------------------+
 *
 *
 * </pre>
 * <p/>
 * And following is a code example to use this API.
 * <pre>
 * 001: TestSuite testSuite = new TestSuite.Builder()
 * 002:     .addFactor("factor1", 1, 2, 3)
 * 003:     .addBooleanFactor("boolean")
 * 004:     .addByteFactor("byte")
 * 005:     .addCharFactor("char")
 * 006:     .addShortFactor("short")
 * 007:     .addIntFactor("int")
 * 008:     .addLongFactor("long")
 * 009:     .addFloatFactor("float")
 * 010:     .addDoubleFactor("double")
 * 011:     .addStringFactor("string")
 * 012:     .addEnumLevels("enum", TestCase.Type.class)
 * 013:     .addConstraint(new TestSuite.Builder.Predicate() {
 * 014:         public boolean apply(Tuple in) {
 * 015:             return !in.get("factor1").equals(1);
 * 016:     }})
 * 017:     .enableNegativeTests()
 * 018: .build();
 * 019:
 * 020: for (TestCase each : testSuite) {
 * 021:     ...
 * 022:     for (Predicate violatedConstraint : TestSuite.getViolatedConstraints(each) {
 * 023:         ...
 * 024:     }
 * 025: }
 * </pre>
 * <p/>
 * Line 002 is defining a new factor with a name {@code factor1} and its levels are {@code 1},
 * {@code 2}, and {@code 3}.
 * Also you can define a new factor using preset levels for all primitive types and {@link java.lang.String}
 * (Line 003-011).
 * If you use {@link com.github.dakusui.jcunit.framework.TestSuite.Builder#addEnumLevels(String, Class)}
 * method, you can add a factor whose levels are enum constants of the enum. (Line 012).
 * <p/>
 * <p/>
 * You probably want to define some constraints over your test suite. For this, you can use
 * {@link com.github.dakusui.jcunit.framework.TestSuite.Builder#addConstraint(com.github.dakusui.jcunit.framework.TestSuite.Predicate)}
 * method. The argument is a predicate which returns {@code false} when a given tuple violates a
 * constraint that is represents.
 * <p/>
 * <p/>
 * In this example, if a level of a factor {@code factor1} becomes {@code 1}, the constraint defined
 * by Line 013-016 will be violated.
 * <p/>
 * <p/>
 * By default, test cases that violate any of given constraints will not be contained in the test suite
 * returned by {@code build()} (Line 018). But in this example we are explicitly requesting the builder
 * to generate "negative tests" by calling {@link com.github.dakusui.jcunit.framework.TestSuite.Builder#enableNegativeTests()}
 * (Line 017).
 * <p/>
 * If it is requested, after "regular" test cases, "violation" test cases will be appended.
 * Violation test cases are generated in a following manner.
 * <ol>
 * <li>For each of constraints, a test case that violates only it but none of the other constraints will be generated.</li>
 * <li>For each level of each factor which is not yet covered by any "regular" test cases,
 * a test case which covers it will be generated by changing the factor's value of one of regular test cases
 * to the uncovered level.</li>
 * </ol>
 * <p/>
 * In order to know whether a test case in a {@link com.github.dakusui.jcunit.framework.TestSuite} is
 * generated as regular or violation one,
 * you can use {@link com.github.dakusui.jcunit.framework.TestCase#getType()} method which returns
 * {@link com.github.dakusui.jcunit.framework.TestCase.Type}.
 * <p/>
 * <p/>
 * Note that even if a test case is generated as a violation one, it may not violate any given constraint.
 * Because if a certain level of a factor is not covered by "regular" test cases, which can happen due to
 * very complex constraint definitions and/or a poor covering array generator, {@code TestSuite.Builder}
 * tries to cover it by modifying regular test case. And it is possible the test case happens not to violate
 * any constraint.
 * <p/>
 * Therefore, the {@code TestCase.Type} returned by {@code TestCase#getType()} method should be considered
 * it is representing "how" it is generated.
 * <p/>
 * <p/>
 * In order to suppress negative test generation, see {@link com.github.dakusui.jcunit.framework.TestSuite.Builder#disableNegativeTests()}.
 * <p/>
 * <p/>
 * Line 020-025, since a {@code TestSuite} is a {@code List} of {@code TestCase} (see also the diagram),
 * you can simply iterate it using a {@code for} statement.
 * Inside this loop, you can execute each test case, format it into a test design document, examine
 * which factors and their levels are covered, etc.
 *
 *
 * To know which constraints are violated by each test case, you can use
 * {@link com.github.dakusui.jcunit.framework.TestSuite#getViolatedConstraints( com.github.dakusui.jcunit.framework.TestCase)}
 * method. (Line 022-024).
 *
 * @see com.github.dakusui.jcunit.framework.TestSuite
 * @see com.github.dakusui.jcunit.framework.TestSuite.Builder
 * @see com.github.dakusui.jcunit.framework.TestCase
 * @see com.github.dakusui.jcunit.framework.TestCase.Type
 * @see com.github.dakusui.jcunit.runners.standard.annotations.FactorField
 * @see java.util.Map
 */
package com.github.dakusui.jcunit.framework;