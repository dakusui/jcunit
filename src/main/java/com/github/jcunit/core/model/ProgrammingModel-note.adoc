[source,java]
[%nowrap,java]
----
import com.github.jcunit.annotations.JCUnitParameterValue;import com.github.jcunit.annotations.Named;
import com.github.jcunit.core.model.ValueResolver;import com.github.jcunit.core.model.ValueResolvers;

@JCUnit(parameterSpace = Example.ParameterSpace.class)
public class ExampleParameterSpaceSpec {
  /*
  public ParameterSpaceSpec parameterSpaceSpec() {
    return ParameterSpaceSpec.create(
        asList(ParameterSpec.create("rootAction",
                                    ValueResolver.fromValue(leaf(System.out::println)),
                                    ValueResolver.fromStaticMethod(classMethod(Example.class, "sequential"),
                                    ValueResolver.fromStaticMethod(classMethod(Example.class, "parallel")),
               ParameterSpec.create("child1",
                                    ValueResolver.fromValue(ActionSupport.nop()),
                                    ValueResolver.fromValue(ActionSupport.leaf(System.out::println))),
               ParameterSpec.create("child2",
                                    ValueResolver.fromValue(ActionSupport.nop()),
                                    ValueResolver.fromValue(ActionSupport.leaf(System.out::println)))
)),

        emptyList()));
  }
   */

  @JCUnitParameter
  public static List<ValueResolver<Action>> rootAction() {
    return List.of(ValueResolver.from(leaf(System.out::println)),
                                    ValueResolvers.fromStaticMethod(classMethod(Example.class, "sequential2"),
                                    ValueResolvers.fromStaticMethod(classMethod(Example.class, "sequential1"),
                                    ValueResolvers.fromStaticMethod(classMethod(Example.class, "parallel")))));
  }

  @JCUnitParameter
  public static List<ValueResolver<Action>> child1() {
    return asList(ActionSuppport.nop(), ActionSupport.leaf(System.out::println));
  }

  @JCUnitParameterValue("sequential1")
  public static Action sequential(@From("child1") Action child1) {
    return ActionSupport.sequential(child1, child2);
  }

  @JCUnitParameterValue("sequential2")
  public static Action sequential(@From("child1") Action child1, @From("child2") Action child2) {
    return ActionSupport.sequential(child1, child2);
  }

  /**
   * By annotating `@Named`, you can specify a string by which you can select the method through `ValueResolver.fromStaticMethod`.
   * If `value` is not given, the name of the method is used the string as default.
   * If this selection become ambiguous, for instance, there are overloaded method that have `@Named` annotations, but their values are default,
   * an exception will be thrown.
   *
   * @param child1 A first child action of a returned parallel action.
   * @param child2 A second child action of a returned parallel action.
   * @return A parallel action, which has actions given as arguments.
   */
  @JCUnitParameterValue("parallel")
  public static List<ValueResolver<Action>> concurrent(@From("child1") Action child1, @From("child2") Action child2) {
    return ActionSupport.parallel(child1, child2);
  }

  @Named
  public static List<ValueResolver<Action>> child1() {
    return asList(ValueResolver.simple(ActionSupport.nop()),
                  ValueResolver.simple(leaf(System.out::println)));
  }

  @Named
  public static List<ValueResolver<Action>> child2() {
    return asList(ValueResolver.simple(ActionSupport.nop()),
                  ValueResolver.simple(leaf(System.out::println)));
  }

  @JCUnitCondition
  public static boolean atLeastOneLeaf(@From("child1") Action child1, @From("child2") Action child2) {
    return child1 instanceof Leaf || child2 instanceof Leaf;
  }

}
----

[source,java]
----
public class Example {

}
----

