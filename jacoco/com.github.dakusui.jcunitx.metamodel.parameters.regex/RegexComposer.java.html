<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RegexComposer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jcunit</a> &gt; <a href="index.source.html" class="el_package">com.github.dakusui.jcunitx.metamodel.parameters.regex</a> &gt; <span class="el_source">RegexComposer.java</span></div><h1>RegexComposer.java</h1><pre class="source lang-java linenums">package com.github.dakusui.jcunitx.metamodel.parameters.regex;

import com.github.dakusui.jcunitx.core.AArray;
import com.github.dakusui.jcunitx.pipeline.stages.Generator;
import com.github.dakusui.jcunitx.regex.Expr;
import com.github.dakusui.jcunitx.regex.Reference;
import com.github.dakusui.jcunitx.regex.RegexTranslator;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import static java.util.Arrays.asList;

public class RegexComposer {
  private final String            prefix;
  private final Expr              topLevel;
  private final Map&lt;String, Expr&gt; exprs;

<span class="fc" id="L21">  public RegexComposer(String prefix, Expr topLevel) {</span>
<span class="fc" id="L22">    this.prefix = prefix;</span>
<span class="fc" id="L23">    this.topLevel = topLevel;</span>
<span class="fc" id="L24">    this.exprs = createMap(this.topLevel);</span>
<span class="fc" id="L25">  }</span>

  /**
   * A method to compose a sequence of `String`s that matches the expression given as `topLevel` from `row`.
   *
   * @param row An internal representation of a sequence matching the `topLevel` expression (`Expr`).
   * @return A sequence matching requested `Expr`.
   */
  public List&lt;String&gt; compose(AArray row) {
<span class="fc" id="L34">    ComposerVisitor visitor = new ComposerVisitor(row, this.exprs);</span>
<span class="fc" id="L35">    this.topLevel.accept(visitor);</span>
<span class="fc" id="L36">    return splitOnWhiteSpaces(visitor.out);</span>
  }

  private List&lt;String&gt; splitOnWhiteSpaces(List&lt;Object&gt; in) {
<span class="fc" id="L40">    List&lt;String&gt; ret = new LinkedList&lt;&gt;();</span>
<span class="fc bfc" id="L41" title="All 2 branches covered.">    for (Object each : in) {</span>
<span class="fc" id="L42">      String eachString = (String) each;</span>
<span class="pc bpc" id="L43" title="1 of 2 branches missed.">      if (!eachString.contains(&quot; &quot;)) {</span>
<span class="fc" id="L44">        ret.add(eachString);</span>
      } else {
<span class="nc" id="L46">        ret.addAll(asList(eachString.split(&quot; +&quot;)));</span>
      }
<span class="fc" id="L48">    }</span>
<span class="fc" id="L49">    return ret;</span>
  }

  private Map&lt;String, Expr&gt; createMap(Expr top) {
<span class="fc" id="L53">    final Map&lt;String, Expr&gt; ret = new HashMap&lt;&gt;();</span>
<span class="fc" id="L54">    top.accept(new Expr.Visitor() {</span>
      @Override
      public void visit(Expr.Alt exp) {
<span class="fc" id="L57">        ret.put(RegexComposer.this.composeKey(exp), exp);</span>
<span class="fc bfc" id="L58" title="All 2 branches covered.">        for (Expr each : exp.getChildren()) {</span>
<span class="fc" id="L59">          each.accept(this);</span>
<span class="fc" id="L60">        }</span>
<span class="fc" id="L61">      }</span>

      @Override
      public void visit(Expr.Cat exp) {
<span class="fc" id="L65">        ret.put(RegexComposer.this.composeKey(exp), exp);</span>
<span class="fc bfc" id="L66" title="All 2 branches covered.">        for (Expr each : exp.getChildren()) {</span>
<span class="fc" id="L67">          each.accept(this);</span>
<span class="fc" id="L68">        }</span>
<span class="fc" id="L69">      }</span>

      @Override
      public void visit(Expr.Leaf exp) {
<span class="fc" id="L73">        ret.put(RegexComposer.this.composeKey(exp), exp);</span>
<span class="fc" id="L74">      }</span>

      @Override
      public void visit(Expr.Empty exp) {
<span class="fc" id="L78">        ret.put(RegexComposer.this.composeKey(exp), exp);</span>
<span class="fc" id="L79">      }</span>
    });
<span class="fc" id="L81">    return ret;</span>
  }

  private String composeKey(Expr expr) {
<span class="fc" id="L85">    return RegexTranslator.composeKey(this.prefix, expr.id());</span>
  }

  private class ComposerVisitor implements Expr.Visitor {
    private final AArray            tuple;
    private final Map&lt;String, Expr&gt; exprs;
<span class="fc" id="L91">    public        List&lt;Object&gt;      out = new LinkedList&lt;&gt;();</span>

<span class="fc" id="L93">    private ComposerVisitor(AArray tuple, Map&lt;String, Expr&gt; exprs) {</span>
<span class="fc" id="L94">      this.tuple = tuple;</span>
<span class="fc" id="L95">      this.exprs = exprs;</span>
<span class="fc" id="L96">    }</span>

    @Override
    public void visit(Expr.Alt expr) {
<span class="fc" id="L100">      Object values = tuple.get(composeKey(expr));</span>
<span class="fc bfc" id="L101" title="All 2 branches covered.">      if (Generator.VOID.equals(values))</span>
<span class="fc" id="L102">        return;</span>
      //noinspection unchecked
<span class="fc bfc" id="L104" title="All 2 branches covered.">      for (Object each : (List&lt;Object&gt;) values) {</span>
<span class="fc bfc" id="L105" title="All 2 branches covered.">        if (each instanceof Reference) {</span>
<span class="fc" id="L106">          this.exprs.get(((Reference) each).key).accept(this);</span>
        } else {
<span class="fc" id="L108">          out.add(each);</span>
        }
<span class="fc" id="L110">      }</span>
<span class="fc" id="L111">    }</span>

    @Override
    public void visit(Expr.Cat expr) {
<span class="fc bfc" id="L115" title="All 2 branches covered.">      for (Expr each : expr.getChildren()) {</span>
<span class="fc" id="L116">        each.accept(this);</span>
<span class="fc" id="L117">      }</span>
<span class="fc" id="L118">    }</span>

    @Override
    public void visit(Expr.Leaf expr) {
<span class="fc" id="L122">      out.add(expr.value());</span>
<span class="fc" id="L123">    }</span>

    @Override
    public void visit(Expr.Empty empty) {

<span class="fc" id="L128">    }</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>