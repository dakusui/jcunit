<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JCUnit8.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jcunit</a> &gt; <a href="index.source.html" class="el_package">com.github.dakusui.jcunitx.runners.junit4</a> &gt; <span class="el_source">JCUnit8.java</span></div><h1>JCUnit8.java</h1><pre class="source lang-java linenums">package com.github.dakusui.jcunitx.runners.junit4;

import com.github.dakusui.jcunitx.core.AArray;
import com.github.dakusui.jcunitx.utils.Checks;
import com.github.dakusui.jcunitx.utils.Utils;
import com.github.dakusui.jcunitx.exceptions.TestDefinitionException;
import com.github.dakusui.jcunitx.factorspace.Constraint;
import com.github.dakusui.jcunitx.metamodel.ParameterSpace;
import com.github.dakusui.jcunitx.pipeline.Config;
import com.github.dakusui.jcunitx.pipeline.Pipeline;
import com.github.dakusui.jcunitx.pipeline.stages.ConfigFactory;
import com.github.dakusui.jcunitx.runners.core.NodeUtils;
import com.github.dakusui.jcunitx.runners.junit4.annotations.*;
import com.github.dakusui.jcunitx.runners.junit4.utils.InternalUtils;
import com.github.dakusui.jcunitx.testsuite.*;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.Description;
import org.junit.runner.Runner;
import org.junit.runner.notification.RunNotifier;
import org.junit.runners.ParentRunner;
import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.InitializationError;
import org.junit.runners.model.Statement;
import org.junit.runners.model.TestClass;
import org.junit.validator.AnnotationsValidator;
import org.junit.validator.PublicClassValidator;
import org.junit.validator.TestClassValidator;

import java.lang.annotation.Annotation;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.*;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.stream.IntStream;
import java.util.stream.Stream;

import static com.github.dakusui.jcunitx.utils.Utils.createTestClassMock;
import static com.github.dakusui.jcunitx.exceptions.FrameworkException.unexpectedByDesign;
import static java.lang.String.format;
import static java.util.stream.Collectors.toList;

public class JCUnit8 extends org.junit.runners.Parameterized {
  private final List&lt;Runner&gt; runners;
  private final TestSuite    testSuite;

  /**
   * Only called reflectively. Do not use programmatically.
   *
   * @param klass A test class
   */
  public JCUnit8(Class&lt;?&gt; klass) throws Throwable {
<span class="fc" id="L55">    super(klass);</span>
<span class="fc" id="L56">    this.runners = createRunners(this.testSuite = buildTestSuite(</span>
<span class="fc" id="L57">        getTestClass(),</span>
<span class="fc" id="L58">        createParameterSpaceDefinitionTestClass(),</span>
<span class="fc" id="L59">        getConfigFactory()</span>
    ));
<span class="fc" id="L61">  }</span>

  private static TestClassValidator[] createValidatorsFor(TestClass parameterSpaceDefinitionClass) {
<span class="fc" id="L64">    return new TestClassValidator[] {</span>
        new AnnotationsValidator(),
        new PublicClassValidator(),
<span class="fc" id="L67">        new TestClassValidator() {</span>
          @Override
          public List&lt;Exception&gt; validateTestClass(TestClass testClass) {
<span class="fc" id="L70">            return new LinkedList&lt;Exception&gt;() {</span>
              {
<span class="fc" id="L72">                validateFromAnnotationsAreReferencingExistingParameterSourceMethods(BeforeTestCase.class, testClass, this);</span>
<span class="fc" id="L73">                validateFromAnnotationsAreReferencingExistingParameterSourceMethods(Before.class, testClass, this);</span>
<span class="fc" id="L74">                validateFromAnnotationsAreReferencingExistingParameterSourceMethods(Test.class, testClass, this);</span>
<span class="fc" id="L75">                validateFromAnnotationsAreReferencingExistingParameterSourceMethods(After.class, testClass, this);</span>
<span class="fc" id="L76">                validateFromAnnotationsAreReferencingExistingParameterSourceMethods(AfterTestCase.class, testClass, this);</span>
<span class="fc" id="L77">                validateAtLeastOneTestMethod(testClass, this);</span>
<span class="fc" id="L78">              }</span>

            };
          }

          private void validateAtLeastOneTestMethod(TestClass testClass, LinkedList&lt;Exception&gt; errors) {
<span class="fc bfc" id="L84" title="All 2 branches covered.">            if (testClass.getAnnotatedMethods(Test.class).isEmpty()) {</span>
<span class="fc" id="L85">              errors.add(new Exception(&quot;No runnable methods&quot;));</span>
            }
<span class="fc" id="L87">          }</span>

          private void validateFromAnnotationsAreReferencingExistingParameterSourceMethods(Class&lt;? extends Annotation&gt; ann, TestClass testClass, List&lt;Exception&gt; errors) {
<span class="fc" id="L90">            testClass.getAnnotatedMethods(ann)</span>
<span class="fc" id="L91">                .forEach(</span>
<span class="fc" id="L92">                    frameworkMethod -&gt; Stream.of(frameworkMethod.getMethod().getParameterAnnotations())</span>
<span class="fc" id="L93">                        .forEach((Annotation[] annotations) -&gt; Stream.of(annotations)</span>
<span class="fc" id="L94">                            .filter((Annotation annotation) -&gt; annotation instanceof From)</span>
<span class="fc" id="L95">                            .forEach((Annotation annotation) -&gt; {</span>
<span class="fc" id="L96">                              List&lt;FrameworkMethod&gt; methods = parameterSpaceDefinitionClass.getAnnotatedMethods(ParameterSource.class)</span>
<span class="fc" id="L97">                                  .stream()</span>
<span class="fc" id="L98">                                  .filter((FrameworkMethod each) -&gt; Objects.equals(each.getName(), ((From) annotation).value()))</span>
<span class="fc" id="L99">                                  .collect(toList());</span>
<span class="fc bfc" id="L100" title="All 2 branches covered.">                              if (methods.isEmpty())</span>
<span class="fc" id="L101">                                errors.add(new Exception(formatMissingParameterSourceMethodMessage((From) annotation)));</span>
<span class="fc" id="L102">                            })));</span>
<span class="fc" id="L103">          }</span>

          private String formatMissingParameterSourceMethodMessage(From annotation) {
<span class="fc" id="L106">            return format(</span>
                &quot;A method '%s' annotated with '%s' is not defined in '%s'&quot;,
<span class="fc" id="L108">                annotation.value(),</span>
<span class="fc" id="L109">                ParameterSource.class.getSimpleName(),</span>
<span class="fc" id="L110">                parameterSpaceDefinitionClass.getJavaClass().getCanonicalName()</span>
            );
          }
        }
    };
  }

  private static ParameterSpace buildParameterSpace(List&lt;com.github.dakusui.jcunitx.metamodel.Parameter&lt;?&gt;&gt; parameters, List&lt;Constraint&gt; constraints) {
<span class="fc" id="L118">    return new ParameterSpace.Builder()</span>
<span class="fc" id="L119">        .addAllParameters(parameters)</span>
<span class="fc" id="L120">        .addAllConstraints(constraints)</span>
<span class="fc" id="L121">        .build();</span>
  }

  private static TestSuite buildTestSuite(Config config, ParameterSpace parameterSpace, TestScenario testScenario) {
<span class="fc" id="L125">    return Pipeline.Standard.create().execute(config, parameterSpace, testScenario);</span>
  }

  private static SortedMap&lt;String, com.github.dakusui.jcunitx.metamodel.Parameter&lt;?&gt;&gt; buildParameterMap(TestClass parameterSpaceDefinitionTestClass) {
<span class="fc" id="L129">    return new TreeMap&lt;String, com.github.dakusui.jcunitx.metamodel.Parameter&lt;?&gt;&gt;() {</span>
      {
<span class="fc" id="L131">        parameterSpaceDefinitionTestClass.getAnnotatedMethods(ParameterSource.class).forEach(</span>
<span class="fc" id="L132">            frameworkMethod -&gt; put(frameworkMethod.getName(),</span>
<span class="fc" id="L133">                buildParameterFactoryCreatorFrom(frameworkMethod)</span>
<span class="fc" id="L134">                    .apply(Utils.createInstanceOf(parameterSpaceDefinitionTestClass))</span>
<span class="fc" id="L135">                    .create(frameworkMethod.getName())</span>
            ));
<span class="fc" id="L137">      }</span>
    };
  }

  private static Function&lt;Object, com.github.dakusui.jcunitx.metamodel.Parameter.Descriptor&lt;?&gt;&gt; buildParameterFactoryCreatorFrom(FrameworkMethod method) {
<span class="fc" id="L142">    return (Object o) -&gt; {</span>
      try {
<span class="fc" id="L144">        return (com.github.dakusui.jcunitx.metamodel.Parameter.Descriptor&lt;?&gt;) method.invokeExplosively(o);</span>
<span class="fc" id="L145">      } catch (Throwable throwable) {</span>
<span class="nc" id="L146">        throw unexpectedByDesign(throwable);</span>
      }
    };
  }

  public static TestSuite buildTestSuite(
      TestClass testClass,
      TestClass parameterSpaceDefinitionTestClass,
      ConfigFactory configFactory
  ) {
<span class="fc" id="L156">    Collection&lt;String&gt; involvedParameterNames = InternalUtils.involvedParameters(testClass);</span>
<span class="fc" id="L157">    return buildTestSuite(</span>
<span class="fc" id="L158">        configFactory.create(),</span>
<span class="fc" id="L159">        buildParameterSpace(</span>
<span class="fc" id="L160">            new ArrayList&lt;&gt;(buildParameterMap(parameterSpaceDefinitionTestClass).values())</span>
<span class="fc" id="L161">                .stream()</span>
<span class="fc" id="L162">                .filter(parameter -&gt; involvedParameterNames.contains(parameter.getName()))</span>
<span class="fc" id="L163">                .collect(toList()),</span>
<span class="fc" id="L164">            NodeUtils.allTestPredicates(testClass).values().stream()</span>
<span class="fc" id="L165">                .filter(each -&gt; each instanceof Constraint)</span>
<span class="fc" id="L166">                .map(Constraint.class::cast)</span>
<span class="fc" id="L167">                .collect(toList())</span>
        ),
<span class="fc" id="L169">        TestScenarioFactoryForJUnit4.create(testClass)</span>
    );
  }

  /**
   * Mock {@code Parameterized} runner of JUnit 4.12.
   */
  @Override
  protected TestClass createTestClass(Class&lt;?&gt; testClass) {
<span class="fc" id="L178">    return createTestClassMock(super.createTestClass(testClass));</span>
  }

  @Override
  protected List&lt;Runner&gt; getChildren() {
<span class="fc" id="L183">    return this.runners;</span>
  }

  @Override
  protected void collectInitializationErrors(List&lt;Throwable&gt; errors) {
<span class="fc" id="L188">    this.applyValidators(errors);</span>
<span class="fc" id="L189">  }</span>

  protected Statement withBeforeClasses(Statement statement) {
<span class="fc bfc" id="L192" title="All 2 branches covered.">    return this.testSuite.getScenario().preSuiteProcedures().isEmpty() ?</span>
        statement :
<span class="fc" id="L194">        InternalUtils.createRunBeforesForTestInput(</span>
            statement,
<span class="fc" id="L196">            this.testSuite.getScenario().preSuiteProcedures(),</span>
<span class="fc" id="L197">            AArray.builder().put(&quot;@suite&quot;, this.testSuite).build()</span>
        );
  }

  protected Statement withAfterClasses(Statement statement) {
<span class="fc bfc" id="L202" title="All 2 branches covered.">    return this.testSuite.getScenario().postSuiteProcedures().isEmpty() ?</span>
        statement :
<span class="fc" id="L204">        InternalUtils.createRunAftersForTestInput(</span>
            statement,
<span class="fc" id="L206">            this.testSuite.getScenario().postSuiteProcedures(),</span>
<span class="fc" id="L207">            AArray.builder().put(&quot;@suite&quot;, this.testSuite).build()</span>
        );
  }

  private List&lt;Runner&gt; createRunners(TestSuite testSuite) {
<span class="fc" id="L212">    return IntStream.range(0, testSuite.size())</span>
<span class="fc" id="L213">        .mapToObj(i -&gt; createTestCaseRunner(testSuite, i))</span>
<span class="fc" id="L214">        .collect(toList());</span>
  }

  private TestCaseRunner createTestCaseRunner(TestSuite testSuite, int i) {
    try {
<span class="fc" id="L219">      return new TestCaseRunner(this.getTestClass().getJavaClass(), i, testSuite);</span>
<span class="nc" id="L220">    } catch (InitializationError initializationError) {</span>
<span class="nc" id="L221">      throw Checks.wrap(initializationError);</span>
    }
  }

  private void applyValidators(List&lt;Throwable&gt; errors) {
<span class="pc bpc" id="L226" title="1 of 2 branches missed.">    if (getTestClass().getJavaClass() != null) {</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">      for (TestClassValidator each : createValidatorsFor(createParameterSpaceDefinitionTestClass())) {</span>
<span class="fc" id="L228">        errors.addAll(each.validateTestClass(getTestClass()));</span>
      }
    }
<span class="fc" id="L231">  }</span>

  private ConfigFactory getConfigFactory() {
    try {
<span class="fc" id="L235">      return getConfigureWithAnnotation().value().newInstance();</span>
<span class="nc" id="L236">    } catch (InstantiationException | IllegalAccessException e) {</span>
<span class="nc" id="L237">      throw TestDefinitionException.wrap(e);</span>
    }
  }

  private TestClass createParameterSpaceDefinitionTestClass() {
<span class="fc" id="L242">    Class&lt;?&gt; parameterSpaceClass = getConfigureWithAnnotation().parameterSpace();</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">    return Objects.equals(parameterSpaceClass, ConfigureWith.DEFAULT_INSTANCE.parameterSpace()) ?</span>
<span class="fc" id="L244">        this.getTestClass() :</span>
        new TestClass(parameterSpaceClass);
  }

  private ConfigureWith getConfigureWithAnnotation() {
<span class="fc" id="L249">    ConfigureWith ret = this.getTestClass().getAnnotation(ConfigureWith.class);</span>
<span class="fc bfc" id="L250" title="All 2 branches covered.">    if (ret == null)</span>
<span class="fc" id="L251">      ret = ConfigureWith.DEFAULT_INSTANCE;</span>
<span class="fc" id="L252">    return ret;</span>
  }

  private static class TestCaseRunner extends ParentRunner&lt;TestOracle&gt; {

    private final int       id;
    private final TestSuite testSuite;

    /**
     * Constructs a new {@code ParentRunner} that will run {@code @TestClass}
     *
     * @param javaClass A class that defines a test suite to be run.
     */
    private TestCaseRunner(Class&lt;?&gt; javaClass, int id, TestSuite testSuite) throws InitializationError {
<span class="fc" id="L266">      super(javaClass);</span>
<span class="fc" id="L267">      this.id = id;</span>
<span class="fc" id="L268">      this.testSuite = testSuite;</span>
<span class="fc" id="L269">    }</span>

    @Override
    protected String getName() {
<span class="fc" id="L273">      return format(&quot;[%d]&quot;, this.id);</span>
    }

    @Override
    protected List&lt;TestOracle&gt; getChildren() {
<span class="fc" id="L278">      return testSuite.getScenario().oracles();</span>
    }

    @Override
    protected Description describeChild(TestOracle child) {
<span class="fc" id="L283">      return Description.createTestDescription(</span>
<span class="fc" id="L284">          getTestClass().getJavaClass(),</span>
<span class="fc" id="L285">          String.format(&quot;%s[%s]&quot;, child.getName(), this.id),</span>
          new Annotation[0]
      );
    }

    @Override
    protected void runChild(TestOracle child, RunNotifier notifier) {
<span class="fc" id="L292">      Description description = describeChild(child);</span>

<span class="fc" id="L294">      TestCase testCase = this.testSuite.get(this.id);</span>
<span class="fc" id="L295">      AArray testInput = composeTestInput(testCase.getTestInput());</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">      if (child.shouldInvoke().test(testInput)) {</span>
<span class="fc" id="L297">        runLeaf(oracleBlock(child, testInput), description, notifier);</span>
      } else {
<span class="fc" id="L299">        notifier.fireTestIgnored(description);</span>
      }
<span class="fc" id="L301">    }</span>

    @Override
    protected void collectInitializationErrors(List&lt;Throwable&gt; errors) {
<span class="fc" id="L305">    }</span>

    @Override
    protected Statement classBlock(final RunNotifier notifier) {
<span class="fc" id="L309">      Statement statement = childrenInvoker(notifier);</span>
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">      if (!checkIfAllChildrenAreIgnored()) {</span>
<span class="fc" id="L311">        statement = withBeforeTestCases(statement);</span>
<span class="fc" id="L312">        statement = withAfterTestCases(statement);</span>
      }
<span class="fc" id="L314">      return statement;</span>
    }

    private Statement withBeforeTestCases(Statement statement) {
<span class="fc bfc" id="L318" title="All 2 branches covered.">      return testSuite.getScenario().preTestInputProcedures().isEmpty() ?</span>
          statement :
<span class="fc" id="L320">          InternalUtils.createRunBeforesForTestInput(statement, testSuite.getScenario().preTestInputProcedures(), this.getTestCase().getTestInput());</span>
    }

    private Statement withAfterTestCases(Statement statement) {
<span class="fc" id="L324">      List&lt;FrameworkMethod&gt; afters = getTestClass().getAnnotatedMethods(AfterTestCase.class);</span>
<span class="fc bfc" id="L325" title="All 2 branches covered.">      return afters.isEmpty() ? statement :</span>
<span class="fc" id="L326">          InternalUtils.createRunAftersForTestInput(statement, testSuite.getScenario().postTestInputProcedures(), this.getTestCase().getTestInput());</span>
    }

    private boolean checkIfAllChildrenAreIgnored() {
      try {
<span class="fc" id="L331">        Method m = ParentRunner.class.getDeclaredMethod(&quot;areAllChildrenIgnored&quot;);</span>
<span class="fc" id="L332">        boolean wasAccessible = m.isAccessible();</span>
<span class="fc" id="L333">        m.setAccessible(true);</span>
        try {
<span class="fc" id="L335">          return (boolean) m.invoke(this);</span>
        } finally {
<span class="fc" id="L337">          m.setAccessible(wasAccessible);</span>
        }
<span class="nc" id="L339">      } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {</span>
<span class="nc" id="L340">        throw new Error(e);</span>
      }
    }

    private AArray composeTestInput(AArray tuple) {
      try {
<span class="fc" id="L346">        return AArray.builder()</span>
<span class="fc" id="L347">            .putAll(tuple)</span>
<span class="fc" id="L348">            .put(&quot;@ins&quot;, getTestClass().getOnlyConstructor().newInstance())</span>
<span class="fc" id="L349">            .put(&quot;@suite&quot;, testSuite)</span>
<span class="fc" id="L350">            .build();</span>
<span class="nc" id="L351">      } catch (InstantiationException | InvocationTargetException | IllegalAccessException e) {</span>
<span class="nc" id="L352">        throw Checks.wrap(e);</span>
      }
    }

    private Statement oracleBlock(TestOracle testOracle, AArray testInput) {
<span class="fc" id="L357">      Statement statement = oracleInvoker(testOracle, testInput);</span>
<span class="fc" id="L358">      statement = withBeforesForTestOracle(testInput, statement);</span>
<span class="fc" id="L359">      statement = withAftersForTestOracle(testInput, statement);</span>
<span class="fc" id="L360">      return statement;</span>
    }

    private Statement oracleInvoker(TestOracle oracle, AArray testInput) {
<span class="fc" id="L364">      return new Statement() {</span>
        @Override
        public void evaluate() {
<span class="fc" id="L367">          oracle.accept(testInput);</span>
<span class="fc" id="L368">        }</span>
      };
    }

    private Statement withBeforesForTestOracle(AArray testInput, Statement statement) {
<span class="fc" id="L373">      List&lt;TestInputConsumer&gt; befores = testSuite.getScenario().preOracleProcedures();</span>
<span class="fc bfc" id="L374" title="All 2 branches covered.">      return befores.isEmpty() ?</span>
          statement :
<span class="fc" id="L376">          new Statement() {</span>
            @Override
            public void evaluate() throws Throwable {
<span class="fc bfc" id="L379" title="All 2 branches covered.">              for (Consumer&lt;AArray&gt; before : befores)</span>
<span class="fc" id="L380">                before.accept(testInput);</span>
<span class="fc" id="L381">              statement.evaluate();</span>
<span class="fc" id="L382">            }</span>
          };
    }

    private Statement withAftersForTestOracle(AArray testInput, Statement statement) {
<span class="fc" id="L387">      List&lt;TestInputConsumer&gt; afters = testSuite.getScenario().postOracleProcedures();</span>
<span class="fc bfc" id="L388" title="All 2 branches covered.">      return afters.isEmpty() ?</span>
          statement :
<span class="fc" id="L390">          new Statement() {</span>
            @Override
            public void evaluate() throws Throwable {
<span class="fc" id="L393">              statement.evaluate();</span>
<span class="fc bfc" id="L394" title="All 2 branches covered.">              for (Consumer&lt;AArray&gt; after : afters)</span>
<span class="fc" id="L395">                after.accept(testInput);</span>
<span class="fc" id="L396">            }</span>
          };
    }

    public TestCase getTestCase() {
<span class="fc" id="L401">      return this.testSuite.get(this.id);</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>